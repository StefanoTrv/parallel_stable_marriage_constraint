
███████ ████████ ██████  ██    ██ ████████ ████████ ██    ██ ██████  ███████     ██████   █████  ████████ ██    
██         ██    ██   ██ ██    ██    ██       ██    ██    ██ ██   ██ ██          ██   ██ ██   ██    ██    ██ ██ 
███████    ██    ██████  ██    ██    ██       ██    ██    ██ ██████  █████       ██   ██ ███████    ██    ██    
     ██    ██    ██   ██ ██    ██    ██       ██    ██    ██ ██   ██ ██          ██   ██ ██   ██    ██    ██ ██ 
███████    ██    ██   ██  ██████     ██       ██     ██████  ██   ██ ███████     ██████  ██   ██    ██    ██    
                                                                                                                
Due vettori aggiuntivi array_mod_men e array_mod_women di "booleani", che contengono VERO per ogni uomo o donna il cui dominio è stato modificato.
Un vettore aggiuntivo di "booleani" array_min_mod_men, che contiene VERO per ogni uomo il cui minimo nel dominio è stato modificato. (Nel caso simmetrico, ci sarà un vettore anche per le donne.)
Due vettori aggiuntivi stack_mod_men e stack_mod_women di interi di dimensione n e due variabili length_men_stack e length_women_stack. I vettori contengono la lista, rispettivamente, degli uomini e delle donne il cui dominio è stato modificato; le due variabili associate indicano fino a quale elemento del vettore è stato riempito, mentre il resto è spazio libero.
Un vettore aggiuntivo stack_mod_min_men di interi di dimensione n e la variabile length_min_men_stack. Il vettore contiene la lista degli uomini il cui minimo nel dominio è stato modificato; la variabile associata indica fino a quale elemento del vettore è stato riempito, mentre il resto è spazio libero. (Nel caso simmetrico, esistono strutture dati analoghe per le donne.)
array_mod_men e array_mod_women sono inizializzati con tutti i valori a FALSO, a meno che non si ipotizzi che i domini ricevuti in input possano non essere coerenti, caso in cui sono inizializzati tutti a VERO. Se i domini di input sono coerenti, stack_mod_men e stack_mod_women non sono inizializzati, e length_men_stack e length_women_stack sono inizializzate a 0. Se i domini di input potessero essere non coerenti, i primi due vettori verrebbero inizializzati con tutti i valori a VERO, gli altri due conterrebbero tutti gli interi fino ad n e le variabili sarebbero inizializzate ad n. Si noti che il caso più generale è quello in cui i domini non siano coerenti, quindi ci riferiremo a quel caso.
array_min_mod_men è inizializzato con tutti i valori a VERO. stack_mod_min_men e length_min_men_stack subiscono una doppia inizializzazione: all'inizio stack_mod_min_men non viene riempito e length_min_men_stack viene inizializzato a 0; quindi durante la prima esecuzione del vincolo, subito dopo l'esecuzione di f1 e prima della prima esecuzione di f2, stack_mod_min_men è inizializzato con tutti gli interi fino ad n-1 incluso e length_min_men_stack è inizializzato ad n. Questo perché la prima esecuzione del vincolo è l'unico caso in cui f2 deve essere eseguito su tutti gli uomini; essendo stack_mod_min_men usato per stabilire su quali uomini eseguire il vincolo (cioé f2), alla prima esecuzione deve essere riempito con tutti gli uomini. Allo stesso tempo, f1 cercherà di riempire stack_mod_min_men con gli uomini il cui minimo è effettivamente cambiato, e se lo stack è già stato riempito finirà probabilmente per cercare di aggiungere uomini fuori dallo spazio dello stack. Con questa doppia inizializzazione, si permette a f1 di riempire lo stack secondo la sua logica interna, quindi si ignora il modo in cui lo ha riempito per riempirlo completamente con tutti i valori. Grazie a questa doppia inizializzazione si evita di aggiungere controlli al kernel, scaricando la responsabilità sul chiamante. (Nel caso simmetrico, le strutture dati aggiuntive sono inizializzate allo stesso modo.)
Si noti che si potrebbe pensare ad eliminare la necessità di inizializzare i vettori di interi utilizzando dei flag aggiuntivi, o in alternativa si potrebbe provare a delegare alla GPU la loro inizializzazione (essa non dovrebbe però essere così pesante da giustificare ciò).
Tutte queste strutture dati sono allocate come memoria mapped, così da poterle modificare facilmente sia da host che da device (questa parte non è fondamentale).
Quando il propagatore per questo vincolo deve essere chiamato, l'host imposta a FALSO gli elementi in array_mod_men e array_mod_women associati a variabili che non sono state modificate, mentre imposta a VERO gli elementi in array_mod_men e array_mod_women associati a variabili il cui dominio è stato modificato; nel secondo caso, inoltre, gli indici di quelle variabili (il numero dell'uomo o della donna) vengono inseriti all'inizio di stack_mod_men o stack_mod_women, e length_men_stack o length_women_stack viene incrementato opportunamente.
Sempre prima della chiamata del propagatore, l'host imposta a FALSO gli elementi in array_min_mod_men associati a variabili il cui minimo del dominio non è stato modificato, mentre imposta a VERO gli elementi in array_min_mod_men associati a variabili il cui minimo nel dominio è stato modificato; nel secondo caso, inoltre, gli indici degli uomini vengono inseriti all'inizio di stack_mod_min_men e length_min_men_stack è incrementato opportunamente. (Nel caso simmetrico, viene fatto lo stesso con le strutture dati relative alle donne.) Nel caso della prima chiamata al vincolo, valgono invece i valori a cui sono state inizializzate le strutture dati.
Quattro vettori aggiuntivi di interi, old_min_men, old_max_men, old_min_women e old_max_women, che contengo i valori minimi e massimi delle variabili degli uomini e delle donne subito dopo l'applicazione precedente del vincolo. I vettori relativi ai minimi sono inizializzati tutti a 0, mentre quelli relativi ai massimi a n-1. Questi vettori sono reversibili (trail), perché devono essere ripristinati con il backtracking; per questo motivo non possono essere salvati come memoria mapped ma devono essere ricaricati ogni volta sul device.
L'intero new_length_min_men_stack e l'array new_stack_mod_min_men vengono usati dalla funzione f2 per memorizzare quali uomini dovranno essere gestiti successivamente da una nuova chiamata della stessa funzione.

si potrebbe fare che il blocco scrive la atomic di fun1 tutti insieme, con una sola chiamata (raggruppando le scritture in global, coordinandosi prima sulla shared)


 █████  ██       ██████   ██████  ██████  ██ ████████ ███    ███  ██████     
██   ██ ██      ██       ██    ██ ██   ██ ██    ██    ████  ████ ██    ██ ██ 
███████ ██      ██   ███ ██    ██ ██████  ██    ██    ██ ████ ██ ██    ██    
██   ██ ██      ██    ██ ██    ██ ██   ██ ██    ██    ██  ██  ██ ██    ██ ██ 
██   ██ ███████  ██████   ██████  ██   ██ ██    ██    ██      ██  ██████     
                                                                             
L'host si occupa di lanciare le diverse fasi di applicazione del vincolo.
Le fasi sono le seguenti:
- redere coerenti i domini: eliminare dai domini degli uomini le donne i cui domini non li contengono più, e viceversa
- applicazione vera e propria del vincolo
- finalizzazione della modifica dei domini e ripristino delle strutture dati
Le strutture dati passate ai kernel sono, oltre a quelle menzionate in precedenza e i domini: le due tabelle delle preferenze, le due tabelle delle preferenze invertite, i minimi e i massimi attuali di tutti i domini (diremo che sono salvati nei vettori min_men, max_men, min_women, max_women).

Fun1: rendere coerenti i domini:
Vengono lanciati un numero di thread pari a length_men_stack + length_women_stack. Ad ogni thread è associato un uomo od una donna presenti in stack_mod_men o stack_mod_women; il thread conosce la persona a cui è associato usando i vettori di interi, il proprio numero di blocco, numero di thread nel blocco e la lunghezza dei vettori.
Una volta che il thread ha calcolato la persona p a cui è associato, usando i vettori old_[min|max]_{wo}men, scansiona tutti i valori nel dominio di p tra old_min(p) e old_max(p) (estremi inclusi) e, se valgono 0 (ovvero non sono presenti nel dominio), si assicura che sia impostato a 0 anche il valore di p nel dominio di questa nuova persona.
Quando questa procedura modifica un dominio, effettua una lettura-scrittura atomica su array_mod_men o array_mod_women per vedere se il dominio era già stato segnalato come modificato; se non era stato segnato, lo segna e aggiorna stack_mod_men o stack_mod_women, con una lettura-incremento atomico di length_men_stack o length_women_stack.
Inoltre, quando modifica il dominio di un uomo, legge old_min_men per vedere se il valore rimosso era il minimo e in caso affermativo modifica array_min_mod_men e, con una lettura-incremento atomica di length_min_men_stack, stack_mod_min_men. (Nel caso simmetrico, lo stesso viene fatto anche per le donne, con le apposite strutture dati.)
Si noti che il vettore max_women potrebbe non contenere più i massimi reali alla fine di questa funzione, ma piuttosto dei valori >= ai massimi. Questo non è un problema, in quanto tutte le proposte che le donne potrebbero ricevere verrebbero accettate, sostituendo il vecchio valore del massimo con quello nuovo o con un nuovo massimo migliore (ovvero più piccolo). Aggiornare immediatamente questi valori non dovrebbe portare a miglioramenti nelle prestazioni, in quanto non incidono sul numero di operazioni eseguite da fun2 e sposterebbe solo del lavoro da f3 a f1. (Nel caso simmetrico, lo stesso ragionamento vale per il vettore dei massimi degli uomini.)

Fun2: applicazione vera e propria del vincolo (per la versione simmetrica, si faccia la stessa cosa invertendo i ruoli di uomini e donne; da valutare se può essere fatto in simultanea):
array_min_mod_men viene resettato a tutti zeri e si imposta il valore di new_length_min_men_stack a 0.
Vengono lanciati length_min_men_stack thread, a ognuno dei quali è assegnato un uomo m presente in array_min_mod_men. (Infatti le modifiche interne ai domini non rompono le coppie migliori.)
Viene usato old_min_men per memorizzare a che punto della lista di ogni uomo siamo arrivati.
Preso quindi il valore di old_min_men di m, per prima cosa si confronta con max_men per assicurarsi che il dominio di m non sia vuoto (il dominio è vuoto quando si supera max_men senza trovare una donna libera); in caso sia vuoto, old_min_men di m viene aggiornato ad m, così che sia possibile verificare che il dominio è vuoto leggendo solo il minimo, e il thread termina. Se il dominio invece non è vuoto, ci si può trovare nel caso in cui questo valore è ancora presente nel dominio oppure nel caso in cui questo valore non è presente nel dominio. È importante considerare entrambi questi due casi, in quanto quando un valore interno di un dominio di un uomo viene rimosso al di fuori della logica del vincolo, potrebbe essere necessario cancellare dei valori da altri domini. Esaminiamo prima il primo caso, per poi entrare più in dettaglio nel secondo.

Caso1: il valore è presente nel dominio
Abbiamo trovato la prima donna nella lista di m che è ancora nel suo dominio, e la chiamiamo w.
Viene effettuata una operazione atomica su max_women di w, in modo che ne legga il valore e lo sovrascriva solo se w preferisce m al suo massimo attuale (ovvero, m<max_women[w] nel dominio degli indici di w). A seconda del valore ritornato dalla operazione atomica, ci si troverà in uno dei seguenti casi:
- w preferisce il suo massimo a m: in questo caso, un uomo che w preferisce ad m si è appena proposto a w. Si imposta old_min_men al valore successivo nel dominio (non necessariamente un valore ancora presente in esso) e si ricomincia questa funzione con lo stesso m. Si noti che non si rimuove w dal dominio di m, in quanto ciò sarà già stato fatto dall'altro uomo che si è appena proposto a w. È fondamentale che l'incremento di old_min_men avvenga non incrementando direttamente il valore che contiene, ma bensì assegnandogli l'indice successivo a quello di w. Se si incrementa di 1 il valore di old_min_men senza assicurarsi che il valore ottenuto sia quello che vogliamo, infatti, due thread che lavorano simultaneamente sugli stessi m e w potrebbero incrementare due volte old_min_men, facendo saltare all'algoritmo, al passo successivo, un valore del dominio e quindi potenzialmente rendendo il risultato finale non corretto. Inoltre, se l'incremento è fatto in modo non atomico, l'algoritmo continua a funzionare correttamente ma old_min_men potrebbe diminuire: bisogna valutare se è maggiore il costo dell'operazione atomica o delle eventuali iterazioni in più dovute alla modifica impropria di old_min.
- il massimo di w è già m: in questo caso w ed m formano già una coppia stabile. Nessuna coppia viene rotta, dunque nessun uomo viene reso libero e quindi il thread termina.
- w preferisce m al suo massimo: w "ha accettato" e il massimo attuale potrebbe essere stato liberato. Si definisca p := max_women[w]. Si procede come segue:
	- Nel momento della lettura atomica, è stato impostato max_women[w]:=m, e la chiamata atomica evita di aumentare il massimo di w.
	- per ogni successore di m nella lista di w fino a p incluso, si cancella w dal suo dominio. Si noti che, in caso questo valore fosse il minimo del rispettivo dominio, gli uomini diversi da p saranno già stati assegnati ad un altro thread, che si occuperà di aggiornarlo. Infatti se il dominio rispetta il vincolo allora w=minOf(m) <=> m=maxOf(w).
	- si imposta m:=p e si torna all'inizio di questa funzione. Si noti che w potrebbe già essere il minimo di p e che quindi il thread potrebbe terminare alla prossima iterazione (a meno di altre modifiche).
	
Caso2: il valore non è presente nel dominio
Quando il vincolo riceve domini completi, i valori interni dei domini degli uomini sono modificati in una sola situazione: la donna relativa a quel valore ha accettato la proposta di un uomo che gradisce di più. Questo ci permette, quando cerchiamo il minimo di un uomo, di ignorare tutti i valori pari a 0 che incontriamo nel suo dominio.
Quando invece il vincolo riceve dei domini a cui sono stati rimossi dei valori al di fuori della logica dell'algoritmo, potrebbe essere necessario effettuare delle ulteriori operazioni nel momento in cui si incontra una valore 0 che era precedentemente interno. In particolare, se la donna avesse accettato una proposta da quest'uomo, è necessario effettuare tutte le modifiche agli altri domini che normalmente vengono eseguite quanto una proposta viene accettata. Nel caso di domini completi, infatti, i valori interni vuoti degli uomini corrispondo a valori nei domini delle donne oltre al massimo attuale delle donne stesse. Invece in questo caso ad alcuni zeri interni nei domini degli uomini posso corrispondere degli zeri interni nei domini delle donne; questi sono i casi in cui la donna avrebbe potuto accettare la proposta. Essendo una proposta che sarebbe stata accetta, questa coppia è bloccante per gli accoppiamenti per cui l'uomo sta con un'altra donna che gradisce di meno e la donna sta con un altro uomo che gradisce di meno. Per i valori mancanti dal dominio dell'uomo, sappiamo che sicuramente egli starà con una donna che gradisce di meno, dunque ogni accoppiamento tra la donna in questione ed un uomo che gradisce di meno non potrà essere presente in un matching stabile. Segue che è necessario rimuovere dal dominio della donna tutti gli uomini che gradisce di meno. Quando incontriamo uno 0 risalendo un dominio degli uomini, dunque, dobbiamo gestire tali valori in modo da assicurare la coerenza dei domini. Più precisamente, il massimo della donna deve essere al più pari all'indice dell'uomo che precede immediatamente l'uomo in questione nel dominio della donna; i domini degli altri uomini che eventualmente vengono rimossi dal dominio della donna, devono essere aggiornati in modo da rimuovere la donna dal loro dominio.
Passando alla descrizione dell'algoritmo, per prima cosa viene aggiornato old_min_men: in questo modo un thread che sta gestendo lo stesso uomo con un po' di ritardo può direttamente passare al prossimo valore nel dominio di m, in quando le operazioni eseguite in questa sottofunzione non sono bloccanti per la logica dell'algoritmo. In questo modo, tale ipotetico thread può procedere con la computazione quando questo thread sta ancora finendo di gestire le eventuali modifiche necessarie.
Sia w la donna relativa al valore vuoto del dominio che abbiamo trovato. Impostiamo in modo atomico il valore del suo max_women al minimo tra il suo valore attuale e il valore dell'uomo che precede m nella sua lista. Se il minimo era già inferiore, allora non è necessario fare nulla, perché lo 0 nel dominio delle donne si trovava già oltre al suo massimo. In caso contrario, si procede a rimuovere w dal dominio di tutti gli uomini presenti nella lista di w tra m e il suo vecchio minimo (forse sufficiente da m+1).
È possibile a questo punto che l'ultimo uomo rimosso dal dominio di w, ovvero il vecchio massimo, abbia avuto il proprio minimo modificato in quanto era effettivamente accoppiato con w. Si noti che, grazie anche alle operazioni atomiche, se questa operazione ha modificato il minimo di un uomo diverso dal vecchio massimo, esso sarà già associato a qualche thread perché sia aggiornato, in quanto per essere in questa situazione vuol dire che il suo minimo era già stato modificato (o ci troviamo al primo lancio del vincolo, il che è sostanzialmente equivalente). Se il vecchio massimo non fosse già, per coincidenza, assegnato a qualche altro thread, in questo passo dell'algoritmo non solo non abbiamo trovato una nuova coppia per m, ma abbiamo anche reso libero un uomo precedentemente accoppiato. Essendo il numero di uomini che possono liberati in tale modo da un singolo thread prima che passi ad un nuovo uomo O(n) (anche se il limite superiore è un caso piuttosto estremo), non è ragionevole assegnare questo nuovo uomo libero a questo stesso thread. Dunque segnialiamo che il vecchio massimo dovrà essere aggiornato in un successivo passaggio di f2: si imposta il valore di array_min_mod_men a 1 in modo atomico, così da evitare doppioni sullo stack, e se non era già stato segnalato come modificato si aggiunge questo uomo a new_stack_mod_min_men, con una lettura-incremento atomico di new_length_min_men_stack per trovare la posizione nello stack in cui inserirlo. È possibile che questo uomo venga aggiornato da un altro thread e che dunque al prossimo lancio di f2 l'uomo non abbia bisogno di essere aggiornato e il kernel dell'uomo termini immediatamente. **

Una volta che tutti i thread sono terminati, si controlla new_length_min_men_stack: se il suo valore è maggiore di 0, si scambiano stack_mod_min_men e new_stack_mod_min_men, si imposta il valore di length_min_men_stack al valore di new_length_min_men_stack e quindi si imposta new_length_min_men_stack a 0, e si mettono a zero tutti i valori di array_min_mod_men. Quindi si rilancia f2. Se invece new_length_min_men_stack è uguale a 0, si procede con f3.


Si noti che i thread non comunicano fra loro quando trovano un dominio che è stato svuotato completamente, così da evitare gli overhead causati dalla sincronizzazione. Non c'è nessun tipo di sincronizzazione tra i thread, che procedono in modo indipendente (si vedano note a seguire).
È necessario valutare se l'esecuzione contemporanea di entrambi i lati simmetrici del vincolo (punto di vista degli uomini e punto di vista delle donne) può creare problemi di concorrenza.
Si noti inoltre che i i valori di old_min_men non vengono scritti con una operazione atomica di atomicMax, per cui potrebbero essere diminuiti invece che aumentati. Questa possibilità però non inficia sulla correttezza dell'algoritmo, e da prove empiriche si è trovato che i casi in cui l'atomicMax sarebbe stato efficacie (ovvero il valore di old_min_men viene diminuito) sono estremamente rari. Si è dunque scelto di non utilizzare in questo punto operazioni atomiche, supponendo che il loro effetto sarebbe stato deleterio per le prestazioni.

Fun3: finalizzazione della modifica dei domini e ripristino delle strutture dati:
Viene lanciato un thread per ogni donna, ovvero n thread. Quindi il thread imposta a 0 i bit del dominio della sua donna w compresi tra max_women[w] (escluso) e old_max_women[w] (incluso), operando il più possibile a livello di parola, così da ridurre il numero di operazioni neccessarie (quindi usando eventualmente una mask in AND per la prima e l'ultima parola e settando tutte le successive a 0, gestendo il caso in cui l'ultima parola contiene il dominio della prossima persona).
(Nel caso simmetrico, si fa la stessa cosa per i massimi degli uomini.)
Quindi ogni thread aggiorna, per un i-esimo uomo e una i-esima donna, old_max_men, old_min_women e old_max_women con i nuovi massimi e minimi (si noti che nel caso asimmetrico i valori in max_men e min_women possono essere valori peggiori dei massimi e dei minimi reali, quindi è necessario scorrere i domini a partire da questi punti per assicurarsi di trovare i valori reali; per old_max_women è sufficiente leggere il valore di max_women). Non è necessario aggiornare old_min_men perché è tenuto aggiornato da f2.
Dopo la chiusura dei kernel, l'host mette a 0 le variabili relative alle lunghezze.

Al termine, eventuali strutture dati che non sono mapped, come i domini e i vettori dei massimi e dei minimi, vengono copiati dall'host nella sua memoria.

Si noti che, al termine di f3, le varie strutture dati potrebbero contenere valori non corretti nel caso fosse stato trovato un dominio vuoto. In questo caso è garantita la correttezza solo dei domini e del vettore old_min_men rispetto al dominio.


███    ██  ██████  ████████ ███████    
████   ██ ██    ██    ██    ██      ██ 
██ ██  ██ ██    ██    ██    █████      
██  ██ ██ ██    ██    ██    ██      ██ 
██   ████  ██████     ██    ███████    
                                       
Alcuni ragionamenti su cui si basa questo algoritmo.
L'idea fondamentale è di non rappresentare esplicitamente le persone libere e le coppie, bensì di associare ad ogni thread una persona al momento libera e usare i massimi e i minimi del dominio come rappresentazione delle coppie, salvo possibili inconsistenze che devono essere ancora corrette. All'intero del codice parallelo, il concetto di dominio modificato di cui si era tenuto traccia si traduce in uomini (e donne nella versione simmetrica) potenzialmente liberi, che devono essere rivalutati.
Nel caso in cui tutti i valori vengono rimossi dal vincolo, un'osservazione molto importante è che ogni proposta libera al più un uomo, dunque è possibile assegnare al thread l'uomo che è stato (forse) liberato, così da non aver bisogno di sincronizzarsi in attesa delle modifiche degli altri thread o ridistribuire gli uomini liberi fra altri thread. Questa supposizione non vale nel caso in cui alcuni valori vengono rimossi al di fuori della logica del vincolo, come approfondito nel caso 2 di f2; per questo motivo si è scelto di memorizzare gli uomini (nel caso asimmetrico) su cui riapplicare f2 in un secondo momento, in quanto non è efficiente ridistribuire questi uomini sui thread che sono già stati lanciati (si pensi ad un singolo thread che libera O(n) uomini). È possibile che, in questo modo, i blocchi si svuotino man mano di thread, così che rimangano in esecuzione diversi blocchi, ognuno con pochi thread; è difficile pensare di riuscire a ridistribuire in modo efficiente gli uomini liberi, così da compattarli negli stessi blocchi.
Grazie alla lettura-scrittura atomica di max_women nel caso 1, un thread che lavora su una donna appena modificata da un altro thread o si accorge che c'è già stata una modifica e quindi che deve ricominciare con le nuove informazioni, oppure riesce a procedere l'esecuzione come se l'altro thread avesse già completato il suo lavoro. Questo ci assicura che la rimozione dei successori di m nella lista di w non liberi nessun uomo che non sia già assegnato ad un altro thread, con la possibile eccezione di p.
I minimi e i massimi non vengono aggiornati allo stesso modo, per evitare problemi di concorrenza durante la ricerca di un nuovo minimo. Questo problema non è presente per quanto riguarda i massimi.
Le modifiche dei valori sulle bitmap vanno effettuate usando operazioni binarie atomiche, per evitare che operazioni contemporanee sulla stessa locazione di memoria (anche su bit diversi) entrino in conflitto (una infatti potrebbe sovrascrivere l'altra).
Una delle criticità principali di questo algoritmo è l'uso abbondante di operazioni atomiche. È difficile pensare di riuscire ad eliminarle senza aggiungere pesanti sincronizzazioni. Un'altra criticità è la possibile necessità di rilanciare più volte f2; è difficile pensare a metodi alternativi che riescono a risolvere in modo più efficiente lo stesso problema.

** «Nel dettaglio, il controllo consiste nel vedere se il minimo attuale del vecchio massimo è effettivamente la donna in questione: in caso contrario, o non si trattava del minimo, oppure un altro thread sta ancora scandendo i valori vuoti del dominio che precedono il minimo effettivo; è possibile che il minimo sia uguale alla donna ma che un altro thread abbia appena iniziato ad aggiornarne il valore, per cui non è necessario rincontrollare successivamente questo uomo: in questo caso il thread che verrà chiamato sull'uomo al prossimo lancio di f2 terminerà immediatamente, salvo modifiche successive al dominio.» Questo controllo si è verificato non funzionare per problemi di concorrenza, in quanto l'alternanza dei thread poteva causare che un minimo fosse minore ma che poi nessun thread ripassasse su quell'uomo. Dopo aver provato a mettere <= invece che == nel confronto, si è verificato che i casi in cui il valore è strettamente maggiore sono così rari da rendere difficile giustificare la presenza di questo controllo, dunque gli uomini vengono segnalati automaticamente come da modificare.